
==================== FINAL INTERFACE ====================
2017-07-22 16:09:12.102687 UTC

interface brainf-ck-0.1.0.0-HFbBDlosSQS35i23lczEiK:BFParser 8002
  interface hash: d17144d97a1fab101a490d2c32e40eb8
  ABI hash: 51348ab300c4d47f46d5ed8ec09b056f
  export-list hash: 86dc52a3516d4c71776040a33d238bfa
  orphan hash: 67d1d64c766b69ff546873c44b345d89
  flag hash: f6624f22fcdd76ed0ac6625466e2d712
  sig of: Nothing
  used TH splices: False
  where
exports:
  BFParser.bfDec
  BFParser.bfDo
  BFParser.bfInc
  BFParser.bfInit
  BFParser.bfPrint
  BFParser.bfRun
  BFParser.chrToStr
  BFParser.kimiNoNaHa
  BFParser.localMap
  BFParser.readExpr
  BFParser.spaces
  BFParser.symbol
  BFParser.BF{BFParser.BF pointer register}
module dependencies:
package dependencies: array-0.5.1.1@array-0.5.1.1 base-4.9.1.0*
                      binary-0.8.3.0@binary-0.8.3.0
                      bytestring-0.10.8.1@bytestring-0.10.8.1
                      containers-0.5.7.1@containers-0.5.7.1
                      deepseq-1.4.2.0@deepseq-1.4.2.0 ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1 mtl-2.2.1@mtl-2.2.1-BLKBelFsPB3BoFeSWSOYj6
                      parsec-3.1.11@parsec-3.1.11-113irVHGgd88sRnywByDNw
                      text-1.2.2.1@text-1.2.2.1-Ji7hMs2U4BkBwavd4taEVR
                      transformers-0.5.2.0@transformers-0.5.2.0
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
         binary-0.8.3.0@binary-0.8.3.0:Data.Binary.Generic
         bytestring-0.10.8.1@bytestring-0.10.8.1:Data.ByteString.Builder
         text-1.2.2.1@text-1.2.2.1-Ji7hMs2U4BkBwavd4taEVR:Data.Text
         text-1.2.2.1@text-1.2.2.1-Ji7hMs2U4BkBwavd4taEVR:Data.Text.Lazy
         text-1.2.2.1@text-1.2.2.1-Ji7hMs2U4BkBwavd4taEVR:Data.Text.Show
         transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.Error
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Complex base-4.9.1.0:Data.Either
                         base-4.9.1.0:Data.Functor.Const base-4.9.1.0:Data.Functor.Identity
                         base-4.9.1.0:Data.List.NonEmpty base-4.9.1.0:Data.Monoid
                         base-4.9.1.0:Data.Semigroup base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:Data.Version base-4.9.1.0:Data.Void
                         base-4.9.1.0:GHC.Exts base-4.9.1.0:GHC.Generics
                         base-4.9.1.0:GHC.IO.Exception base-4.9.1.0:GHC.TypeLits
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntMap.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntSet.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Sequence
                         containers-0.5.7.1@containers-0.5.7.1:Data.Set.Base
                         text-1.2.2.1@text-1.2.2.1-Ji7hMs2U4BkBwavd4taEVR:Data.Text
                         text-1.2.2.1@text-1.2.2.1-Ji7hMs2U4BkBwavd4taEVR:Data.Text.Lazy
import  -/  base-4.9.1.0:Data.Char 01433d23661edb6e5ef1536ef1e6774c
import  -/  base-4.9.1.0:Data.Either 20b09ef8d0a5b74fdec011c40c1587f5
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:GHC.Char 9d27e5fcb214fa9fb17cf295b3795fce
import  -/  base-4.9.1.0:GHC.List ab8c4e523e6c479c549d3bcd5fc4a439
import  -/  base-4.9.1.0:GHC.Num 00bfaa7b2f9d6084913c0697a8a49ec8
import  -/  base-4.9.1.0:GHC.Show a027f5ac24879eaba752f44aa90fe511
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  base-4.9.1.0:System.IO c9de64c5f5407c4cf1c52500c4d15200
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
import  -/  ghc-prim-0.5.0.0:GHC.Types 89f8de4f08018c9177c98d979eae0e45
import  -/  parsec-3.1.11@parsec-3.1.11-113irVHGgd88sRnywByDNw:Text.Parsec.Char d53119cfb6cc359f4e0f9ede64e0f78f
import  -/  parsec-3.1.11@parsec-3.1.11-113irVHGgd88sRnywByDNw:Text.Parsec.Combinator 66f1086aa7a42f6659ea2da2b481ca67
import  -/  parsec-3.1.11@parsec-3.1.11-113irVHGgd88sRnywByDNw:Text.Parsec.Prim 09b8e7124f6cf9e8a58a20d480bbf894
import  -/  parsec-3.1.11@parsec-3.1.11-113irVHGgd88sRnywByDNw:Text.Parsec.String 51cfdd88fd21b0eb9bc7dcb50c6d3f2c
import  -/  parsec-3.1.11@parsec-3.1.11-113irVHGgd88sRnywByDNw:Text.ParserCombinators.Parsec 09138eb929906f6c6f6f40463cb9c077
84041b663721eacb21714f0ac0c87baf
  $fShowBF :: GHC.Show.Show BFParser.BF
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BFParser.BF
                  BFParser.$fShowBF_$cshowsPrec
                  BFParser.$fShowBF_$cshow
                  BFParser.$fShowBF_$cshowList -}
84041b663721eacb21714f0ac0c87baf
  $fShowBF1 :: BFParser.BF -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ (w :: BFParser.BF) (w1 :: GHC.Base.String) ->
                 case w of ww { BFParser.BF ww1 ww2 ->
                 BFParser.$w$cshowsPrec 0# ww1 ww2 w1 }) -}
0a1361d0a4f287474de5d9a0c082d1ff
  $fShowBF2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "}"#) -}
5cf689948c661335bceafbe638846d8e
  $fShowBF3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "pointer = "#) -}
3803a09319203d3f981fe2be81fb8c01
  $fShowBF4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# ", "#) -}
4dfa88e75b4da4454350a77c7f7c41e1
  $fShowBF5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "register = "#) -}
89e11bd4976253381c0a11bcf80fd925
  $fShowBF6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "BF {"#) -}
84041b663721eacb21714f0ac0c87baf
  $fShowBF_$cshow :: BFParser.BF -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: BFParser.BF) ->
                 BFParser.$fShowBF_$cshowsPrec
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
84041b663721eacb21714f0ac0c87baf
  $fShowBF_$cshowList :: [BFParser.BF] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ BFParser.BF
                   BFParser.$fShowBF1) -}
84041b663721eacb21714f0ac0c87baf
  $fShowBF_$cshowsPrec ::
    GHC.Types.Int -> BFParser.BF -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S(S),1*U(U)><S,1*U(1*U,1*U(U))><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: BFParser.BF)
                   (w2 :: GHC.Base.String) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { BFParser.BF ww3 ww4 ->
                 BFParser.$w$cshowsPrec ww1 ww3 ww4 w2 } }) -}
7adfa78d26ba850b2cb3edd41f6a6e34
  $s$fStream[]mtok ::
    Text.Parsec.Prim.Stream [tok] Data.Functor.Identity.Identity tok
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ tok.
                  @ [tok]
                  @ Data.Functor.Identity.Identity
                  @ tok
                  (BFParser.$s$fStream[]mtok_$s$fStream[]mtok_$cp1Stream @ tok)
                  (BFParser.$s$fStream[]mtok_$s$fStream[]mtok_$cuncons @ tok) -}
9fb5c817cb61cedcbc8b16351c72c604
  $s$fStream[]mtok_$s$fStream[]mtok_$cp1Stream ::
    GHC.Base.Monad Data.Functor.Identity.Identity
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                (\ @ tok -> Data.Functor.Identity.$fMonadIdentity) -}
10bbaa3b33cb42460c30a02bb1fe71be
  $s$fStream[]mtok_$s$fStream[]mtok_$cuncons ::
    [tok]
    -> Data.Functor.Identity.Identity (GHC.Base.Maybe (tok, [tok]))
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ tok (ds :: [tok]) ->
                 case ds of wild {
                   []
                   -> GHC.Base.$
                        @ 'GHC.Types.PtrRepLifted
                        @ (GHC.Base.Maybe (tok, [tok]))
                        @ (Data.Functor.Identity.Identity (GHC.Base.Maybe (tok, [tok])))
                        (Data.Functor.Identity.$fApplicativeIdentity_$cpure
                           @ (GHC.Base.Maybe (tok, [tok])))
                        (GHC.Base.Nothing @ (tok, [tok]))
                   : t ts
                   -> GHC.Base.$
                        @ 'GHC.Types.PtrRepLifted
                        @ (GHC.Base.Maybe (tok, [tok]))
                        @ (Data.Functor.Identity.Identity (GHC.Base.Maybe (tok, [tok])))
                        (Data.Functor.Identity.$fApplicativeIdentity_$cpure
                           @ (GHC.Base.Maybe (tok, [tok])))
                        (GHC.Base.Just @ (tok, [tok]) (t, ts)) }) -}
36acb9053ee5f0a834b9ec45be612cdb
  $ssubtract :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><S(S),1*U(U)>m,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, True)
                (\ (x :: GHC.Types.Int) (y :: GHC.Types.Int) ->
                 GHC.Num.$fNumInt_$c- y x) -}
9b128628f15713a8111b8dc3d6d14fe7
  $tc'BF :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13986939392491324300##
                   8031988439935839536##
                   BFParser.$trModule
                   BFParser.$tc'BF1) -}
11c0ee944518c2e9fecf4e90a19c03a7
  $tc'BF1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'BF"#) -}
43ee0f0c88495959e00eeb7a0d12da7b
  $tcBF :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13378253073611017916##
                   8949808319827576806##
                   BFParser.$trModule
                   BFParser.$tcBF1) -}
0ef42b4783f2e20888b1a5a69a45b66a
  $tcBF1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "BF"#) -}
70358134522c421cc2161fb7b5acb794
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   BFParser.$trModule2
                   BFParser.$trModule1) -}
f7d34375d6d484287c93db8dedf5a72b
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "BFParser"#) -}
f2d09977a67f4248164fc3dc1670419f
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "brainf-ck-0.1.0.0-HFbBDlosSQS35i23lczEiK"#) -}
b9dc843cb5f256cee941c39736b90d38
  $w$cshowsPrec ::
    GHC.Prim.Int#
    -> [GHC.Types.Int]
    -> GHC.Types.Int
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 4, Strictness: <S,U><L,1*U><L,1*U(U)><L,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: [GHC.Types.Int])
                   (ww2 :: GHC.Types.Int)
                   (w :: GHC.Base.String) ->
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                   = \ (x :: GHC.Base.String)[OneShot] ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       BFParser.$fShowBF6
                       (GHC.Base.++
                          @ GHC.Types.Char
                          BFParser.$fShowBF5
                          (let {
                             s :: GHC.Base.String
                             = GHC.Base.++
                                 @ GHC.Types.Char
                                 BFParser.$fShowBF4
                                 (GHC.Base.++
                                    @ GHC.Types.Char
                                    BFParser.$fShowBF3
                                    (case ww2 of ww3 { GHC.Types.I# ww4 ->
                                     case GHC.Show.$wshowSignedInt
                                            0#
                                            ww4
                                            (GHC.Base.++
                                               @ GHC.Types.Char
                                               BFParser.$fShowBF2
                                               x) of ww5 { (#,#) ww6 ww7 ->
                                     GHC.Types.: @ GHC.Types.Char ww6 ww7 } }))
                           } in
                           case ww1 of wild {
                             [] -> GHC.CString.unpackAppendCString# "[]"# s
                             : x1 xs
                             -> GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.showList__2
                                  (case x1 of ww3 { GHC.Types.I# ww4 ->
                                   case GHC.Show.$wshowSignedInt
                                          0#
                                          ww4
                                          (let {
                                             lvl27 :: [GHC.Types.Char]
                                             = GHC.Types.: @ GHC.Types.Char GHC.Show.showList__1 s
                                           } in
                                           letrec {
                                             showl :: [GHC.Types.Int] -> GHC.Base.String
                                               {- Arity: 1, Strictness: <S,1*U> -}
                                             = \ (ds2 :: [GHC.Types.Int]) ->
                                               case ds2 of wild1 {
                                                 [] -> lvl27
                                                 : y ys
                                                 -> GHC.Types.:
                                                      @ GHC.Types.Char
                                                      GHC.Show.shows5
                                                      (case y of ww5 { GHC.Types.I# ww6 ->
                                                       case GHC.Show.$wshowSignedInt
                                                              0#
                                                              ww6
                                                              (showl ys) of ww7 { (#,#) ww8 ww9 ->
                                                       GHC.Types.: @ GHC.Types.Char ww8 ww9 } }) }
                                           } in
                                           showl xs) of ww5 { (#,#) ww6 ww7 ->
                                   GHC.Types.: @ GHC.Types.Char ww6 ww7 } }) }))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11#) of wild {
                   GHC.Types.False -> p w
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows7
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 w)) }) -}
eeea1feed961e8da1518e3af75883cca
  $w$slocalMap ::
    (GHC.Types.Int -> GHC.Types.Int)
    -> GHC.Prim.Int# -> [GHC.Types.Int] -> [GHC.Types.Int]
  {- Arity: 3, Strictness: <L,1*C1(U(U))><S,U><L,U>, Inline: [0],
     Unfolding: (\ (w :: GHC.Types.Int -> GHC.Types.Int)
                   (ww :: GHC.Prim.Int#)
                   (w1 :: [GHC.Types.Int]) ->
                 let {
                   n :: GHC.Types.Int = w (GHC.List.$w!! @ GHC.Types.Int w1 ww)
                 } in
                 let {
                   n1 :: [GHC.Types.Int]
                   = let {
                       x :: GHC.Prim.Int# = GHC.Prim.+# ww 1#
                     } in
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.<=# x 0#) of wild {
                       GHC.Types.False -> BFParser.$wunsafeDrop @ GHC.Types.Int x w1
                       GHC.Types.True -> w1 }
                 } in
                 let {
                   n2 :: [GHC.Types.Int] = GHC.Types.: @ GHC.Types.Int n n1
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# 0# ww) of wild {
                   GHC.Types.False -> n2
                   GHC.Types.True
                   -> letrec {
                        $wgo :: [GHC.Types.Int] -> GHC.Prim.Int# -> [GHC.Types.Int]
                          {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0] -}
                        = \ (w2 :: [GHC.Types.Int]) (ww1 :: GHC.Prim.Int#) ->
                          case w2 of wild1 {
                            [] -> n2
                            : y ys
                            -> case ww1 of ds1 {
                                 DEFAULT
                                 -> GHC.Types.: @ GHC.Types.Int y ($wgo ys (GHC.Prim.-# ds1 1#))
                                 1# -> GHC.Types.: @ GHC.Types.Int y n2 } }
                      } in
                      $wgo w1 ww }) -}
7fb64cfb764481cafc977234dc54f21b
  $wbfRun' ::
    GHC.Base.String
    -> [GHC.Types.Int]
    -> GHC.Types.Int
    -> (# [GHC.Types.Int], GHC.Types.Int #)
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U(U)>, Inline: [0] -}
967ad0b4f774b7d78f57a2ca9812ce04
  $wkimiNoNaHa :: [a] -> a -> GHC.Prim.Int# -> [a]
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,U><S,U>,
     Inline: [0],
     Unfolding: (\ @ a (w :: [a]) (w1 :: a) (ww :: GHC.Prim.Int#) ->
                 let {
                   n :: [a]
                   = let {
                       x :: GHC.Prim.Int# = GHC.Prim.+# ww 1#
                     } in
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.<=# x 0#) of wild {
                       GHC.Types.False -> BFParser.$wunsafeDrop1 @ a x w
                       GHC.Types.True -> w }
                 } in
                 let {
                   n1 :: [a] = GHC.Types.: @ a w1 n
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# 0# ww) of wild {
                   GHC.Types.False -> n1
                   GHC.Types.True
                   -> letrec {
                        $wgo :: [a] -> GHC.Prim.Int# -> [a]
                          {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0] -}
                        = \ (w2 :: [a]) (ww1 :: GHC.Prim.Int#) ->
                          case w2 of wild1 {
                            [] -> n1
                            : y ys
                            -> case ww1 of ds1 {
                                 DEFAULT -> GHC.Types.: @ a y ($wgo ys (GHC.Prim.-# ds1 1#))
                                 1# -> GHC.Types.: @ a y n1 } }
                      } in
                      $wgo w ww }) -}
13a6cfdadce28d912e712b0968cbf864
  $wlocalMap :: (a -> a) -> GHC.Prim.Int# -> [a] -> [a]
  {- Arity: 3, Strictness: <L,1*C1(U)><S,U><L,U>, Inline: [0],
     Unfolding: (\ @ a
                   (w :: a -> a)
                   (ww :: GHC.Prim.Int#)
                   (w1 :: [a]) ->
                 let {
                   n :: a = w (GHC.List.$w!! @ a w1 ww)
                 } in
                 let {
                   n1 :: [a]
                   = let {
                       x :: GHC.Prim.Int# = GHC.Prim.+# ww 1#
                     } in
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.<=# x 0#) of wild {
                       GHC.Types.False -> BFParser.$wunsafeDrop2 @ a x w1
                       GHC.Types.True -> w1 }
                 } in
                 let {
                   n2 :: [a] = GHC.Types.: @ a n n1
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# 0# ww) of wild {
                   GHC.Types.False -> n2
                   GHC.Types.True
                   -> letrec {
                        $wgo :: [a] -> GHC.Prim.Int# -> [a]
                          {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0] -}
                        = \ (w2 :: [a]) (ww1 :: GHC.Prim.Int#) ->
                          case w2 of wild1 {
                            [] -> n2
                            : y ys
                            -> case ww1 of ds1 {
                                 DEFAULT -> GHC.Types.: @ a y ($wgo ys (GHC.Prim.-# ds1 1#))
                                 1# -> GHC.Types.: @ a y n2 } }
                      } in
                      $wgo w1 ww }) -}
d777ed4dad81f16f0703a78853d8d471
  $wlvl ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 4, Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ b1
                   (w :: Text.Parsec.Prim.State [GHC.Types.Char] ())
                   (w1 :: GHC.Types.Char
                          -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1)
                   (w2 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1)
                   (w3 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1) ->
                 Text.Parsec.Combinator.$wskipMany1
                   @ GHC.Base.String
                   @ Data.Functor.Identity.Identity
                   @ GHC.Types.Char
                   @ ()
                   @ GHC.Types.Char
                   BFParser.readExpr6
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <GHC.Base.String>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Char>_R))
                   @ b1
                   w
                   (\ (x :: ())
                      (s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ())[OneShot]
                      (err :: Text.Parsec.Error.ParseError)[OneShot] ->
                    case s2 of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                    case ww2 of ww4 { Text.Parsec.Pos.SourcePos ww5 ww6 ww7 ->
                    Text.Parsec.Char.$wsatisfy
                      @ GHC.Base.String
                      @ Data.Functor.Identity.Identity
                      @ ()
                      (BFParser.$s$fStream[]mtok @ GHC.Types.Char)
                      BFParser.readExpr4
                      @ b1
                      ww1
                      ww5
                      ww6
                      ww7
                      ww3
                      w1
                      (\ (err' :: Text.Parsec.Error.ParseError) ->
                       w2 (Text.Parsec.Error.mergeError err err')) } })
                   w2
                   (\ (x :: ())
                      (s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ())[OneShot]
                      (err :: Text.Parsec.Error.ParseError)[OneShot] ->
                    case s2 of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                    case ww2 of ww4 { Text.Parsec.Pos.SourcePos ww5 ww6 ww7 ->
                    Text.Parsec.Char.$wsatisfy
                      @ GHC.Base.String
                      @ Data.Functor.Identity.Identity
                      @ ()
                      (BFParser.$s$fStream[]mtok @ GHC.Types.Char)
                      BFParser.readExpr4
                      @ b1
                      ww1
                      ww5
                      ww6
                      ww7
                      ww3
                      w1
                      (\ (err' :: Text.Parsec.Error.ParseError) ->
                       w3 (Text.Parsec.Error.mergeError err err')) } })
                   w3) -}
02beb92bd8e765c69d85673aa673e38d
  $wunsafeDrop :: GHC.Prim.Int# -> [a1] -> [a1]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U>,
     Inline: [0] -}
735d846a87dd97714a3702d4e3407da9
  $wunsafeDrop1 :: GHC.Prim.Int# -> [a1] -> [a1]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U>,
     Inline: [0] -}
c401852b2d4c12736975047e9f17a87d
  $wunsafeDrop2 :: GHC.Prim.Int# -> [a1] -> [a1]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U>,
     Inline: [0] -}
84041b663721eacb21714f0ac0c87baf
  data BF
    = BF {register :: [GHC.Types.Int], pointer :: GHC.Types.Int}
87aa28fd8c6cd3f21aa712329a1bc727
  bfDec :: BFParser.BF -> BFParser.BF
  {- Arity: 1, Strictness: <S,1*U(U,U(U))>m,
     Unfolding: InlineRule (1, True, False)
                (\ (bf :: BFParser.BF) ->
                 case bf of wild { BFParser.BF ds ds1 ->
                 BFParser.BF
                   (BFParser.bfDec_$slocalMap BFParser.bfDec1 ds1 ds)
                   ds1 }) -}
620698d4ea3d5257629ab01adf481e23
  bfDec1 :: GHC.Types.Int -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs,
     Unfolding: (BFParser.$ssubtract BFParser.bfDec2) -}
5806375508e7594a4958f8da346dd527
  bfDec2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 1#) -}
efd3194a723c92bcd8a73db9d45306d7
  bfDec_$slocalMap ::
    (GHC.Types.Int -> GHC.Types.Int)
    -> GHC.Types.Int -> [GHC.Types.Int] -> [GHC.Types.Int]
  {- Arity: 3, Strictness: <L,1*C1(U(U))><S(S),1*U(U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int -> GHC.Types.Int)
                   (w1 :: GHC.Types.Int)
                   (w2 :: [GHC.Types.Int]) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 BFParser.$w$slocalMap w ww1 w2 }) -}
8e88b0380c4c1a27497d2177633dafdb
  bfDo :: BFParser.BF -> GHC.Types.Char -> BFParser.BF
  {- Arity: 2, Strictness: <S,1*U(U,U(U))><S(S),1*U(1*U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (bf :: BFParser.BF) (cmd :: GHC.Types.Char) ->
                 case cmd of wild { GHC.Types.C# ds ->
                 case ds of ds1 {
                   DEFAULT -> BFParser.bfDo1
                   '+'# -> BFParser.bfInc bf
                   '-'# -> BFParser.bfDec bf } }) -}
cb3c5153a5f4df7b2fc70314d917a93f
  bfDo1 :: BFParser.BF
  {- Strictness: x -}
0e70440e920fe7d0ec40590cae62bd3a
  bfInc :: BFParser.BF -> BFParser.BF
  {- Arity: 1, Strictness: <S,1*U(U,U(U))>m,
     Unfolding: InlineRule (1, True, False)
                (\ (bf :: BFParser.BF) ->
                 case bf of wild { BFParser.BF ds ds1 ->
                 BFParser.BF
                   (BFParser.bfDec_$slocalMap BFParser.bfInc1 ds1 ds)
                   ds1 }) -}
b957aab28013f5419039a82817885b6b
  bfInc1 :: GHC.Types.Int -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: GHC.Types.Int) ->
                 case ds of wild { GHC.Types.I# x ->
                 GHC.Types.I# (GHC.Prim.+# x 1#) }) -}
3a081ed9ce9aee9093ea9ff62cff67bc
  bfInit :: BFParser.BF
  {- Strictness: m,
     Unfolding: (BFParser.BF BFParser.bfInit2 BFParser.bfInit1) -}
167ec6c660b54511b8c3c82f1bd00dd8
  bfInit1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
9bdce609ac0ef65dd8e87c5a74fd8f37
  bfInit2 :: [GHC.Types.Int]
  {- Unfolding: (GHC.Enum.efdInt 0# 0#) -}
d88dea4da3bf1b1c6b9730cf15f19e17
  bfPrint :: BFParser.BF -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <L,1*U(1*U,1*U(U))><S,U>,
     Unfolding: InlineRule (0, True, True)
                BFParser.bfPrint1
                  `cast`
                (<BFParser.BF>_R ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
81f48d56cb032fb33ce918e4c5ca3bc8
  bfPrint1 ::
    BFParser.BF
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <L,1*U(1*U,1*U(U))><S,U>,
     Unfolding: (\ (bf :: BFParser.BF)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 GHC.IO.Handle.Text.hPutStr2
                   GHC.IO.Handle.FD.stdout
                   (GHC.Types.:
                      @ GHC.Types.Char
                      (case bf of wild { BFParser.BF ds ds1 ->
                       case ds1 of ww { GHC.Types.I# ww1 ->
                       case GHC.List.$w!!
                              @ GHC.Types.Int
                              ds
                              ww1 of wild1 { GHC.Types.I# i# ->
                       case GHC.Prim.tagToEnum#
                              @ GHC.Types.Bool
                              (GHC.Prim.leWord# (GHC.Prim.int2Word# i#) 1114111##) of wild2 {
                         GHC.Types.False -> GHC.Char.chr2 i#
                         GHC.Types.True -> GHC.Types.C# (GHC.Prim.chr# i#) } } } })
                      (GHC.Types.[] @ GHC.Types.Char))
                   GHC.Types.False
                   eta) -}
73c3580cdaed8dc1cbf907a0049432ae
  bfRun :: GHC.Base.String -> BFParser.BF
  {- Arity: 1, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (cmd :: GHC.Base.String) ->
                 BFParser.bfRun_bfRun' cmd BFParser.bfInit) -}
cb077b1eb1f7678b196ac53d93a9ffcc
  bfRun_bfRun' :: GHC.Base.String -> BFParser.BF -> BFParser.BF
  {- Arity: 2, Strictness: <S,1*U><S,1*U(U,U(U))>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Base.String) (w1 :: BFParser.BF) ->
                 case w1 of ww { BFParser.BF ww1 ww2 ->
                 case BFParser.$wbfRun' w ww1 ww2 of ww3 { (#,#) ww4 ww5 ->
                 BFParser.BF ww4 ww5 } }) -}
5b8ea63b98e8ca7037a35f4c7ff1adc8
  chrToStr :: GHC.Types.Char -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m2,
     Unfolding: InlineRule (1, True, False)
                (\ (chr :: GHC.Types.Char) ->
                 GHC.Types.:
                   @ GHC.Types.Char
                   chr
                   (GHC.Types.[] @ GHC.Types.Char)) -}
49cf304f4bc101b544df02ede9eb6911
  kimiNoNaHa :: [a] -> a -> GHC.Types.Int -> [a]
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,U><S(S),1*U(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a (w :: [a]) (w1 :: a) (w2 :: GHC.Types.Int) ->
                 case w2 of ww { GHC.Types.I# ww1 ->
                 BFParser.$wkimiNoNaHa @ a w w1 ww1 }) -}
7b2ebcde4c92adea56ae1b50e70e32ac
  localMap ::
    GHC.Num.Num a => (a -> a) -> GHC.Types.Int -> [a] -> [a]
  {- Arity: 4, Strictness: <L,A><L,1*C1(U)><S(S),1*U(U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   (w :: GHC.Num.Num a)
                   (w1 :: a -> a)
                   (w2 :: GHC.Types.Int)
                   (w3 :: [a]) ->
                 case w2 of ww { GHC.Types.I# ww1 ->
                 BFParser.$wlocalMap @ a w1 ww1 w3 }) -}
847ccd493985cf3b05e01ba6cb385105
  pointer :: BFParser.BF -> GHC.Types.Int
  RecSel Left BFParser.BF
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U(U))>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: BFParser.BF) ->
                 case ds of wild { BFParser.BF ds1 ds2 -> ds2 }) -}
9f84d2bf87d6481378baacd0868a559c
  readExpr :: GHC.Base.String -> GHC.Base.String
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: (\ (input :: GHC.Base.String) ->
                 case (Text.Parsec.Prim.runPT
                         @ GHC.Base.String
                         @ Data.Functor.Identity.Identity
                         @ GHC.Types.Char
                         @ ()
                         @ GHC.Types.Char
                         (BFParser.$s$fStream[]mtok @ GHC.Types.Char)
                         BFParser.readExpr3
                           `cast`
                         (Sym (Text.Parsec.Prim.N:ParsecT[0]
                                   <[GHC.Types.Char]>_R
                                   <()>_R
                                   <Data.Functor.Identity.Identity>_R
                                   <GHC.Types.Char>_R))
                         GHC.Tuple.()
                         BFParser.readExpr2
                         input)
                        `cast`
                      (Data.Functor.Identity.N:Identity[0]
                           <Data.Either.Either
                              Text.Parsec.Error.ParseError GHC.Types.Char>_R) of wild {
                   Data.Either.Left err
                   -> GHC.CString.unpackAppendCString#
                        "No match:"#
                        (Text.Parsec.Error.$fShowParseError_$cshow err)
                   Data.Either.Right val -> BFParser.readExpr1 }) -}
d029bf477dca039546c8a16af6389e87
  readExpr1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Foudn value"#) -}
8701c1698a4df6f6bd530b7b3942da44
  readExpr2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "brainf*ck"#) -}
caae7de7fc1aac64112411a1f181a0b8
  readExpr3 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5, Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,A><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (5, True, True)
                (\ @ b1
                   (w :: Text.Parsec.Prim.State [GHC.Types.Char] ())
                   (w1 :: GHC.Types.Char
                          -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1)
                   (w2 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1)
                   (w3 :: GHC.Types.Char
                          -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1)
                   (w4 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1) ->
                 BFParser.$wlvl @ b1 w w1 w2 w4) -}
617a28f582186a0144306e7cc042c9c0
  readExpr4 :: GHC.Types.Char -> GHC.Types.Bool
  {- Arity: 1,
     Unfolding: (\ (c :: GHC.Types.Char) ->
                 GHC.List.elem
                   @ GHC.Types.Char
                   GHC.Classes.$fEqChar
                   c
                   BFParser.readExpr5) -}
c42e0442b5d41f4b02e0484d78f4abbc
  readExpr5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "+-<>[],."#) -}
a6671367db03b654452c5bfc791de598
  readExpr6 ::
    Text.Parsec.Prim.State GHC.Base.String ()
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: (\ @ b
                   (eta :: Text.Parsec.Prim.State GHC.Base.String ())
                   (eta1 :: GHC.Types.Char
                            -> Text.Parsec.Prim.State GHC.Base.String ()
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta2 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta3 :: GHC.Types.Char
                            -> Text.Parsec.Prim.State GHC.Base.String ()
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta4 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Prim.<?>2
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ GHC.Types.Char
                   BFParser.readExpr8
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <GHC.Base.String>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Char>_R))
                   BFParser.readExpr7
                   @ b
                   eta
                   eta1
                   eta2
                   eta3
                   eta4) -}
495ccf976500c4fa7441d6fdc7595283
  readExpr7 :: [GHC.Base.String]
  {- Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   Text.Parsec.Char.space2
                   (GHC.Types.[] @ GHC.Base.String)) -}
5225edf9e73524defb0ca27374dd05f8
  readExpr8 ::
    Text.Parsec.Prim.State GHC.Base.String ()
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Unfolding: (\ @ b
                   (w2 :: Text.Parsec.Prim.State GHC.Base.String ())[OneShot]
                   (w3 :: GHC.Types.Char
                          -> Text.Parsec.Prim.State GHC.Base.String ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)[OneShot]
                   (w4 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)[OneShot]
                   (w5 :: GHC.Types.Char
                          -> Text.Parsec.Prim.State GHC.Base.String ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)[OneShot]
                   (w6 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)[OneShot] ->
                 case w2 of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 case ww2 of ww4 { Text.Parsec.Pos.SourcePos ww5 ww6 ww7 ->
                 Text.Parsec.Char.$wsatisfy
                   @ GHC.Base.String
                   @ Data.Functor.Identity.Identity
                   @ ()
                   (BFParser.$s$fStream[]mtok @ GHC.Types.Char)
                   GHC.Unicode.isSpace
                   @ b
                   ww1
                   ww5
                   ww6
                   ww7
                   ww3
                   w3
                   w6 } }) -}
4194d64094e19bc57a3745829356db7b
  register :: BFParser.BF -> [GHC.Types.Int]
  RecSel Left BFParser.BF
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: BFParser.BF) ->
                 case ds of wild { BFParser.BF ds1 ds2 -> ds1 }) -}
0ce402c4798c5180f6a56d5d93340fb5
  spaces :: Text.Parsec.String.Parser ()
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (0, True, True)
                BFParser.spaces1
                  `cast`
                (Sym (Text.Parsec.Prim.N:ParsecT[0]
                          <GHC.Base.String>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <()>_R)) -}
998601b048435cbf4a21d757b0c39e54
  spaces1 ::
    Text.Parsec.Prim.State GHC.Base.String ()
    -> (()
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (()
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (w2 :: Text.Parsec.Prim.State GHC.Base.String ())
                   (w3 :: ()
                          -> Text.Parsec.Prim.State GHC.Base.String ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w5 :: ()
                          -> Text.Parsec.Prim.State GHC.Base.String ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w6 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 Text.Parsec.Combinator.$wskipMany1
                   @ GHC.Base.String
                   @ Data.Functor.Identity.Identity
                   @ GHC.Types.Char
                   @ ()
                   @ GHC.Types.Char
                   BFParser.readExpr6
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <GHC.Base.String>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Char>_R))
                   @ b
                   w2
                   w3
                   w4
                   w5
                   w6) -}
4247e72268040af5bf3e70a9c39b68bd
  symbol :: Text.Parsec.String.Parser GHC.Types.Char
  {- Arity: 5,
     Strictness: <S(LS(LSS)S),1*U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,A><L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                BFParser.symbol1
                  `cast`
                (Sym (Text.Parsec.Prim.N:ParsecT[0]
                          <GHC.Base.String>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <GHC.Types.Char>_R)) -}
17525a9b1eddc5e1175cfbb95507b6c0
  symbol1 ::
    Text.Parsec.Prim.State GHC.Base.String ()
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S(LS(LSS)S),1*U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,A><L,A><L,C(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (w :: Text.Parsec.Prim.State GHC.Base.String ())
                   (w1 :: GHC.Types.Char
                          -> Text.Parsec.Prim.State GHC.Base.String ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w2 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w3 :: GHC.Types.Char
                          -> Text.Parsec.Prim.State GHC.Base.String ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                   (w4 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b) ->
                 case w of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 case ww2 of ww4 { Text.Parsec.Pos.SourcePos ww5 ww6 ww7 ->
                 Text.Parsec.Char.$wsatisfy
                   @ GHC.Base.String
                   @ Data.Functor.Identity.Identity
                   @ ()
                   (BFParser.$s$fStream[]mtok @ GHC.Types.Char)
                   BFParser.readExpr4
                   @ b
                   ww1
                   ww5
                   ww6
                   ww7
                   ww3
                   w1
                   w4 } }) -}
instance [safe] GHC.Show.Show [BFParser.BF] = BFParser.$fShowBF
"SPEC localMap @ Int" [ALWAYS] forall ($dNum :: GHC.Num.Num
                                                  GHC.Types.Int)
  BFParser.localMap @ GHC.Types.Int $dNum = BFParser.bfDec_$slocalMap
"SPEC/BFParser $fStream[]mtok @ Identity _" [ALWAYS] forall @ tok
                                                            ($dMonad :: GHC.Base.Monad
                                                                          Data.Functor.Identity.Identity)
  Text.Parsec.Prim.$fStream[]mtok @ Data.Functor.Identity.Identity
                                  @ tok
                                  $dMonad
  = BFParser.$s$fStream[]mtok @ tok
"SPEC/BFParser $fStream[]mtok_$cp1Stream @ Identity _" [ALWAYS] forall @ tok
                                                                       ($dMonad :: GHC.Base.Monad
                                                                                     Data.Functor.Identity.Identity)
  Text.Parsec.Prim.$fStream[]mtok_$cp1Stream @ Data.Functor.Identity.Identity
                                             @ tok
                                             $dMonad
  = BFParser.$s$fStream[]mtok_$s$fStream[]mtok_$cp1Stream @ tok
"SPEC/BFParser $fStream[]mtok_$cuncons @ Identity _" [ALWAYS] forall @ tok
                                                                     ($dMonad :: GHC.Base.Monad
                                                                                   Data.Functor.Identity.Identity)
  Text.Parsec.Prim.$fStream[]mtok_$cuncons @ Data.Functor.Identity.Identity
                                           @ tok
                                           $dMonad
  = BFParser.$s$fStream[]mtok_$s$fStream[]mtok_$cuncons @ tok
"SPEC/BFParser subtract @ Int" [ALWAYS] forall ($dNum :: GHC.Num.Num
                                                           GHC.Types.Int)
  GHC.Num.subtract @ GHC.Types.Int $dNum = BFParser.$ssubtract
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

